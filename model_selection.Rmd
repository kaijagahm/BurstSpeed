---
title: "Model_Selection"
author: "Kaija Gahm"
date: "2/12/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load libraries
```{r}
source("libraries.R")
```

# Load data
```{r}
load("data/outputs/stats_fast3.Rda") # this includes lab and wild tads
```

# Further data cleaning
## Code random effects explicitly
We should have used different letters for the individuals in the two temperature treatments, because strictly speaking we should have labeled the individuals before choosing which ones to put into which temperature treatment. We did select those randomly, but the naming scheme that we chose does not reflect that.

We don't want to change the letters on the tadpoles because that would make the data be out of sync with all of the labels on everything up to this point. Instead, we're going to stick with our scheme of appending "high" or "low" to the names to distinguish e.g. CPS_01_A in high/low treatments (since that is NOT the same individual.)
```{r}
stats_fast3 <- stats_fast3 %>% # remove tadpole column
  mutate(clutch = factor(paste(pond, clutch)), # code clutches explicitly
         indiv = factor(paste(clutch, indiv, treatment))) # code individuals explicitly
locate.nas(stats_fast3)

stats_fast3 <- stats_fast3 %>%
  mutate(burst_date = dmy(paste(burst_day, burst_month, burst_year, sep = "_")))
```

## Select relevant columns and change data types
```{r}
dat3 <- stats_fast3 %>% select(tadpole, trial, indiv, treatment, sline_speed_mm_s, PC1, PC2, pond, size, clutch, mass, gs, T_initial, camera, burst_date) %>% ungroup() %>% mutate(treatment = factor(treatment),
                     pond = factor(pond),
                     clutch = factor(clutch)) %>%
  filter(treatment %in% c("High", "Low"), !is.na(PC1)) %>% droplevels()

# wild tadpoles are separate
wild <- stats_fast3 %>% select(tadpole, trial, treatment, sline_speed_mm_s, PC1, PC2, pond, size, mass, gs, T_initial, camera, burst_date) %>% ungroup() %>% mutate(treatment = factor(treatment),
                     pond = factor(pond)) %>% 
  filter(treatment == "Wild") %>% droplevels()

# fix NA's for pond
wild %>% filter(is.na(pond))
wild$pond[is.na(wild$pond)] <- str_extract(wild$tadpole[is.na(wild$pond)], pattern = "(?<=^)[[:upper:]]{2,3}(?=\\_)")
```

## Export the data for modeling
```{r}
save(dat3, file = "data/outputs/dat3.Rda")
save(wild, file = "data/outputs/wild.Rda")
```

## Remove NA's
### Wild 
#### Remove NA's
```{r}
wild_nonas <- wild[complete.cases(wild),] # remove NA's
wild_nonas <- wild_nonas %>% filter(!is.na(T_initial), !is.na(mass))
```
#### Add pond temps
```{r}
## Add pond temps
load("data/outputs/pond_avg_temps.Rda") # Load pond temperatures
wild_nonas <- wild_nonas %>% left_join(pond_avg_temps, by = "pond")

## Add all relevant dates
load("data/outputs/wild_dates.Rda")
wild_dates <- wild_dates %>%
  select(-pond) # remove pond before joining

wild_nonas <- wild_nonas %>% # join dates
  left_join(wild_dates, by = "tadpole")

locate.nas(wild_nonas) # check for NA's
```

#### Save wild_nonas
```{r}
save(wild_nonas, file = "data/outputs/wild_nonas.Rda")
```

### Lab-reared
#### Remove NA's
```{r}
dat3_nonas <- dat3 %>% filter(!is.na(T_initial) & !is.na(mass))
locate.nas(dat3_nonas)
```

#### Save dat3_nonas
```{r}
save(dat3_nonas, file = "data/outputs/dat3_nonas.Rda")
```

# Mixed modeling
Hierarchical mixed model, incorporating pond within clutch and accounting for multiple trials per individual
Dat3: fastest 3 trials per tadpole

## Establish random effect structure
```{r}
mod1 <- lmer(sline_speed_mm_s ~ treatment * mass + (1|pond/clutch) + (1|indiv) + (1|camera), data = dat3_nonas)
summary(mod1)

# without the camera
modx <- lmer(sline_speed_mm_s ~ treatment * mass + (1|pond/clutch) + (1|indiv), data = dat3_nonas)
summary(modx)

# exclude mass and camera
modpond <- lmer(sline_speed_mm_s ~ treatment + (1|pond/clutch) + (1|indiv), data = dat3_nonas)
summary(modpond)

# remove indiv
modpond2 <- lmer(sline_speed_mm_s ~ treatment + (1|pond/clutch), data = dat3_nonas)
summary(modpond2)

# removing the pond and camera random effects, because they don't tell us much. In fact, we need to remove the pond effect to get a non-singular fit.
mod3 <- lmer(sline_speed_mm_s ~ treatment * mass + (1|clutch/indiv), data = dat3_nonas) # use this syntax, but remember that clutch already accounts for being nested thin pond. 
# note that if we add camera to this model, it doesn't converge.

# : specifies that clutch is nested within pond, but without first fitting pond (since we discovered we don't need to)
# / explicitly fits pond first and then clutch.

dat3_nonas$predicted_speed <- predict(mod1, re.form = NA, newdata = dat3_nonas)
dat3_nonas$predicted_speed_withresids <- predict(mod1, re.form = NA, newdata = dat3_nonas) + resid(mod1, newdata = dat3_nonas)
```

## Check random effect structure
```{r}
# Compare ggplots
dat3_nonas %>% ggplot(aes(x = mass, y = sline_speed_mm_s, col = treatment))+
  geom_point()+
  geom_smooth(method = "lm")+
  ylab("speed (mm/s)")+
  ggtitle("Original data")

dat3_nonas %>% ggplot(aes(x = mass, y = predicted_speed, col = treatment))+
  geom_point()+
  geom_smooth(method = "lm")+
  ylab("predicted_speed (mm/s)")+
  ggtitle("Predicted data")

dat3_nonas %>% ggplot(aes(x = mass, y = predicted_speed_withresids, col = treatment))+
  geom_point()+
  geom_smooth(method = "lm")+
  ylab("predicted_speed_withresids (mm/s)")+
  ggtitle("Predicted data with residuals")
```
The similarity between these graphs shows us that we have correctly specified the structure of our random effects


## Figure out main effects
### Investigate correlations
```{r}
#dat3_nonas %>% select(PC1, PC2, size, mass, gs, T_initial, treatment) %>% ggpairs()
```
Size, mass, and gosner stage are all closely correlated. 

### Standardize variables
```{r}
# Function to calculate z scores
standardize <- function(vector){
  mu <- mean(vector)
  sd <- sd(vector)
  z_vector <- (vector-mu)/sd
  return(z_vector)
}

dat3_nonas_std <- dat3_nonas %>% mutate_at(.vars = c("PC1", "PC2", "mass", "size", "gs", "T_initial"), standardize)
save(dat3_nonas_std, file = "data/outputs/dat3_nonas_std.Rda")
```

## Select variables
We know from various papers that shape, development, size (mass), temperature water during the trial affect burst speed.
Variables:
 - Tadpole mass (as a measure of size)
 - Temperature treatment (as a measure of developmental/growth rate)
 - Gosner stage (as a measure of development)
 - Tray temperature (experimental conditions)
 
The performance at any given mass or GS may be impacted by the developmental rate, so we'll allow for temp_treatment:mass and temp_treatment:gs. Tray temperature varied so little between the two temperature treatments that we didn't consider an interaction there, including only the additive effect.
```{r}
dat3_nonas %>%
  ggplot(aes(x = T_initial, col = treatment))+
  geom_density()

dat3_nonas %>%
  ggplot(aes(x = T_initial, y = sline_speed_mm_s, col = treatment))+
  geom_point()+
  geom_smooth(method = "lm") # ok yeah we definitely do not need an interaction term here.
```

### Shape variables
Independent of body size
We can use either PC1 (ratio of body length to total length) or PC2 (ratio of depth to length)
Because they're principal components, they're orthogonal. Neither is particularly strongly correlated with mass or Gosner stage.
Which is a better predictor of speed?
```{r}
dat3_nonas %>% ggplot(aes(x = PC1, y = sline_speed_mm_s, col = treatment))+
  geom_point()+
  geom_smooth(method = "lm")

dat3_nonas %>% ggplot(aes(x = PC2, y = sline_speed_mm_s, col = treatment))+
  geom_point()+
  geom_smooth(method = "lm")

# PC2 appears to be a slightly better predictor of speed.
```
We'll use PC2 for now, and then we'll compare models later on to see which is better once other variables are taken into account.

## Model selection
### Fit full model
Using unstandardized values for now.
```{r}
full <- lmer(sline_speed_mm_s ~ mass*treatment + gs*treatment + PC2 + T_initial + (1|pond/clutch/tadpole), data = dat3_nonas)
summary(full)
```

## Select a model
Since all of the top 5 basically give the same results, we're going to choose model 1. 
```{r}
consensus_mod <- m1
summary(consensus_mod)

# Get R-squared
MuMIn::r.squaredGLMM(consensus_mod)

# Confidence intervals for the coefficients
#confint.merMod(consensus_mod, method = "boot", nsim = 1000, oldNames = FALSE)

save(consensus_mod, file = "data/outputs/consensus_mod.Rda")
summary(consensus_mod)
```

## Check residuals
```{r}
dat3_nonas_std <- dat3_nonas_std %>% mutate(resid = resid(consensus_mod))
formula(consensus_mod)

dat3_nonas_std %$% qqnorm(resid)
plot(consensus_mod) # looks roughly normal, but just to make sure, we'll do individual plots

dat3_nonas_std %>% ggplot(aes(x = gs, y = resid))+
  geom_point() +
  facet_wrap(~treatment) # the gosner stage data violates the equal variance assumption

dat3_nonas_std %>% ggplot(aes(x = T_initial, y = resid))+
  geom_point() +
  facet_wrap(~treatment)

dat3_nonas_std %>% ggplot(aes(x = resid, col = treatment))+
  geom_density(aes(fill = treatment), alpha = 0.5)
```

## Add variance structure
```{r}
# # this is how we fitted our original model, mod_gs
# formula(consensus_mod)
# summary(consensus_mod)
# 
# mod_nostruct <- lme(sline_speed_mm_s ~ mass*treatment + gs + T_initial,
#          random = ~ 1 | clutch/indiv,
#          data = dat3_nonas_std)
# summary(mod_nostruct)
# 
# mod_varfixed <- lme(sline_speed_mm_s ~ mass*treatment + gs + T_initial,
#          random = ~ 1 | clutch/indiv,
#          weights = varFixed(~gs),
#          data = dat3_nonas_std)
# summary(mod_varfixed)
# 
# mod_varident <- lme(sline_speed_mm_s ~ mass*treatment + gs + T_initial,
#          random = ~ 1 | clutch/indiv,
#          weights = varIdent(form = ~ 1 | factor(as.character(gs))),
#          data = dat3_nonas_std)
# 
# # mod_varpower <- lme(sline_speed_mm_s ~ mass*treatment + gs + T_initial,
# #          random = ~ 1 | clutch/indiv,
# #          weights = varPower(form = ~ gs),
# #          data = dat3_nonas)
# # summary(mod_varpower) # but we shouldn't use this, since gs can take a value of 0 once scaled.
# 
# mod_varexp <- lme(sline_speed_mm_s ~ mass*treatment + gs + T_initial,
#          random = ~ 1 | clutch/indiv,
#          weights = varExp(form = ~ gs),
#          data = dat3_nonas_std)
# summary(mod_varexp)
# 
# mod_varconstpower <- lme(sline_speed_mm_s ~ mass*treatment + gs + T_initial,
#          random = ~ 1 | clutch/indiv,
#          weights = varConstPower(form = ~ gs),
#          data = dat3_nonas_std)
# summary(mod_varconstpower)


#anova(mod_nostruct, mod_varfixed, mod_varident, mod_varexp, mod_varconstpower) # var_nostruct actually wins
```

# Save model with structure
```{r}
# consensus_mod_varident <- mod_varident
# save(consensus_mod_varident, file = "data/outputs/consensus_mod_varident")
```

# Wild tadpoles
## Model selection
### Variable standardization
```{r}
# Function to calculate z scores
standardize <- function(vector){
  mu <- mean(vector)
  sd <- sd(vector)
  z_vector <- (vector-mu)/sd
  return(z_vector)
}

wild_nonas_std <- wild_nonas %>% mutate_at(.vars = c("PC1", "PC2", "mass", "size", "gs", "T_initial", "avg_pond_temp"), standardize)
save(wild_nonas_std, file = "data/outputs/wild_nonas_std.Rda")
```

### Dredging
```{r}
# Full model, with no pond effect
full <- lmer(sline_speed_mm_s ~ PC2*mass*gs*avg_pond_temp + T_initial + (1 | tadpole),
             data = wild_nonas_std, 
             na.action = "na.fail", 
             REML = F)
# Do the same mean-based analysis on this one as I did for the lab-reared tadpoles. 
# What impact does the lab experiment have in the wild? Significance. 

# Dredge full model
#wild_full_dredge <- dredge(full)
#save(wild_full_dredge, file = "data/outputs/wild_full_dredge.Rda")
```

### Fit top five models
```{r}
load("data/outputs/wild_full_dredge.Rda")
wild_full_dredge[1:5,] # take a look at the top five models

m1 <- lmer(sline_speed_mm_s ~ mass + (1 | tadpole), data = wild_nonas_std, REML = F, 
           na.action = "na.fail")

m2 <- lmer(sline_speed_mm_s ~ mass + avg_pond_temp + (1 | tadpole), data = wild_nonas_std, REML = F, 
           na.action = "na.fail")

m3 <- lmer(sline_speed_mm_s ~ mass + PC2 + (1 | tadpole), data = wild_nonas_std, REML = F, 
           na.action = "na.fail")

m4 <- lmer(sline_speed_mm_s ~ gs + (1 | tadpole), data = wild_nonas_std, REML = F, 
           na.action = "na.fail")

m5 <- lmer(sline_speed_mm_s ~ mass + T_initial + (1 | tadpole), data = wild_nonas_std, REML = F, 
           na.action = "na.fail")
```

### Create new df of means
```{r}
wild_newdf <- wild_nonas_std %>% select(tadpole) # select grouping cols
newdf_means <- wild_nonas_std %>% summarize(mass = mean(mass), # take mean of each
                                      gs = mean(gs),
                                      T_initial = mean(T_initial),
                                      PC2 = mean(PC2),
                                      avg_pond_temp = mean(avg_pond_temp))

wild_newdf[,2:6] <- newdf_means # bind grouping cols to means
wild_newdf <- wild_newdf %>% mutate(model1 = predict(m1, wild_newdf), # predict on means with each model
                          model2 = predict(m2, wild_newdf),
                          model3 = predict(m3, wild_newdf),
                          model4 = predict(m4, wild_newdf),
                          model5 = predict(m5, wild_newdf))

wild_df_preds <- wild_newdf %>% select(model1, model2, model3, model4, model5) %>% 
  pivot_longer(cols = c(model1, model2, model3, model4, model5), # put into long format
               names_to = "model",
               values_to = "predicted_speed")

# Boxplot of predictions on means
wild_df_preds %>% ggplot(aes(y = predicted_speed))+
  geom_boxplot()+
  facet_wrap(~model)+
  ylab("predicted speed (mm/s)")+
  ggtitle("Comparison of top 5 models, predicted on means of data")
```

### Select top model
```{r}
# Select reduced model: best AIC
reduced_model <- lmer(sline_speed_mm_s ~ mass + (1 | tadpole),
                data = wild_nonas_std,
                na.action = "na.fail",
                REML = F)
summary(reduced_model)

# Get R-squared
MuMIn::r.squaredGLMM(reduced_model)

# Get confidence intervals for the coefficients
#confint.merMod(reduced_model, method = "boot", nsim = 1000, oldNames = FALSE)

consensus_mod_wild <- reduced_model
save(consensus_mod_wild, file = "data/outputs/consensus_mod_wild.Rda")

wild_nonas_std %>% ggplot(aes(x = mass, y = sline_speed_mm_s))+
  geom_point(alpha = 0.4)+
  geom_smooth(method = "lm", col = "black")+
  xlab("Mass")+
  ylab("Burst speed (mm/s)")
```

## Re-create the lab-reared model: model selection be damned!
```{r}
formula(consensus_mod)

replica_mod_wild <- lmer(sline_speed_mm_s ~ mass * avg_pond_temp + gs + T_initial + (1 | tadpole), data = wild_nonas_std)

summary(replica_mod_wild)
MuMIn::r.squaredGLMM(replica_mod_wild)
#confint.merMod(replica_mod_wild, method = "boot", nsim = 1000, oldNames = FALSE)
save(replica_mod_wild, file = "data/outputs/replica_mod_wild.Rda")
```

