---
title: "Analysis"
author: "Kaija Gahm"
date: "1/22/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load libraries
```{r, echo = F}
source("libraries.R")
```

# Load data
```{r}
load("data/outputs/stats_fast3.Rda")
```

# Code random effects explicitly
We should have used different letters for the individuals in the two temperature treatments, because strictly speaking we should have labeled the individuals before choosing which ones to put into which temperature treatment. We did select those randomly, but the naming scheme that we chose does not reflect that.

We don't want to change the letters on the tadpoles because that would make the data be out of sync with all of the labels on everything up to this point. Instead, we're going to stick with our scheme of appending "high" or "low" to the names to distinguish e.g. CPS_01_A in high/low treatments (since that is NOT the same individual.)
```{r}
stats_fast3 <- stats_fast3 %>% # remove tadpole column
  mutate(clutch = factor(paste(pond, clutch)), # code clutches explicitly
         indiv = factor(paste(clutch, indiv, treatment))) # code individuals explicitly
locate.nas(stats_fast3)
```

## Select relevant columns and change data types
```{r}
dat3 <- stats_fast3 %>% select(tadpole, trial, indiv, treatment, sline_speed_m_s, PC1, PC2, pond, size, clutch, mass, gs, T_initial) %>% ungroup() %>% mutate(treatment = factor(treatment),
                     pond = factor(pond),
                     clutch = factor(clutch)) %>%
  filter(treatment %in% c("High", "Low"), !is.na(PC1)) %>% droplevels()

wild <- stats_fast3 %>% select(tadpole, trial, treatment, sline_speed_m_s, PC1, PC2, pond, size, mass, gs, T_initial) %>% ungroup() %>% mutate(treatment = factor(treatment),
                     pond = factor(pond)) %>% 
  filter(treatment == "Wild") %>% droplevels()
```

## Remove observations that are NA for mass
```{r}
dat3 <- dat3 %>% filter(!is.na(mass))
```


# Mixed modeling
Hierarchical mixed model, incorporating pond within clutch and accounting for multiple trials per individual
Dat3: fastest 3 trials per tadpole

## Establish random effect structure
```{r}
library(lmerTest)
mod1 <- lmer(sline_speed_m_s ~ treatment * mass + (1|pond/clutch) + (1|indiv), data = dat3)
summary(mod1)

# removing the pond random effect, because it doesn't tell us anything. In fact, we need to do this to get a non-singular fit.
mod2 <- lmer(sline_speed_m_s ~ treatment * mass + (1|pond:clutch) + (1|indiv), data = dat3)
mod3 <- lmer(sline_speed_m_s ~ treatment * mass + (1|clutch/indiv), data = dat3) # use this syntax, but remember that clutch already accounts for being nested within pond. 

# : specifies that clutch is nested within pond, but without first fitting pond (since we discovered we don't need to)
# / explicitly fits pond first and then clutch.


dat3$predicted_speed <- predict(mod1, re.form = NA, newdata = dat3)
dat3$predicted_speed_withresids <- predict(mod1, re.form = NA, newdata = dat3) + resid(mod1, newdata = dat3)
```

## Check random effect structure
```{r}
# Compare ggplots
dat3 %>% ggplot(aes(x = mass, y = sline_speed_m_s, col = treatment))+
  geom_point()+
  geom_smooth(method = "lm")+
  ylab("speed")+
  ggtitle("Original data")

dat3 %>% ggplot(aes(x = mass, y = predicted_speed, col = treatment))+
  geom_point()+
  geom_smooth(method = "lm")+
  ylab("predicted_speed")+
  ggtitle("Predicted data")

dat3 %>% ggplot(aes(x = mass, y = predicted_speed_withresids, col = treatment))+
  geom_point()+
  geom_smooth(method = "lm")+
  ylab("predicted_speed_withresids")+
  ggtitle("Predicted data with residuals")
```
The similarity between these graphs shows us that we have correctly specified the structure of our random effects

## Figure out main effects
### Investigate correlations
```{r}
dat3 %>% select(PC1, PC2, size, mass, gs, T_initial, treatment) %>% ggpairs()
```
Size, mass, and gosner stage are all closely correlated. 

### Remove NA's
```{r}
dat3_nonas <- dat3 %>% filter(!is.na(T_initial))
```

#[RE-DO THIS PART]: PC of size and mass, not gs. 
### PCA on size variables
```{r}
size_pca <- prcomp(dat3_nonas %>% select(gs, size, mass))
dat3_nonas$size_pc1 <- size_pca$x[,1]# put the size principal component into the data frame
size_pca
```

### Standardize variables
```{r}
# Function to calculate z scores
standardize <- function(vector){
  mu <- mean(vector)
  sd <- sd(vector)
  z_vector <- (vector-mu)/sd
  return(z_vector)
}

dat3_nonas <- dat3_nonas %>% mutate_at(.vars = c("PC1", "PC2", "mass", "size", "gs", "size_pc1", "T_initial"), standardize)
```

### Fit full models
```{r}
fullmodel_mass <- lmer(sline_speed_m_s ~ PC1*PC2*mass*treatment + T_initial + (1|clutch/indiv), data = dat3_nonas, na.action = "na.fail", REML = FALSE) 

fullmodel_size <- lmer(sline_speed_m_s ~ PC1*PC2*size*treatment + T_initial + (1|clutch/indiv), data = dat3_nonas, na.action = "na.fail", REML = FALSE)

fullmodel_gs <- lmer(sline_speed_m_s ~ PC1*PC2*gs*treatment + T_initial + (1|clutch/indiv), data = dat3_nonas, na.action = "na.fail", REML = FALSE) # SINGULAR

fullmodel_pc <- lmer(sline_speed_m_s ~ PC1*PC2*size_pc1*treatment + T_initial + (1|clutch/indiv), data = dat3_nonas, na.action = "na.fail", REML = FALSE) # SINGULAR
```

### Dredge full models
```{r}
#dredge_mass_best <- dredge(fullmodel_mass)[1,]
#dredge_size_best <- dredge(fullmodel_size)[1,]
#dredge_gs_best <- dredge(fullmodel_gs)[1,]
#dredge_pc_best <- dredge(fullmodel_pc)[1,]

#dredge_info_best <- list(dredge_mass_best, dredge_size_best, dredge_gs_best, dredge_pc_best)
#save(dredge_info_best, file = "data/outputs/dredge_info_best.Rda")

load("data/outputs/dredge_info_best.Rda")

# Make models from the info
dredge_info_best # look at the model selection table for the top models

# recreate the top models
mod_mass <- lmer(sline_speed_m_s ~ mass*treatment + PC2 + T_initial + (1 | clutch/indiv), data = dat3_nonas)

mod_size <- lmer(sline_speed_m_s ~ size*treatment + PC1 + T_initial + (1 | clutch/indiv), data = dat3_nonas)

mod_gs <- lmer(sline_speed_m_s ~ gs*treatment*PC1 + T_initial + (1 | clutch/indiv), data = dat3_nonas)

mod_pc <- lmer(sline_speed_m_s ~ PC1*treatment*size_pc1 + T_initial + (1 | clutch/indiv), data = dat3_nonas) # this one is singular

aic_table <- AIC(mod_mass, mod_size, mod_gs, mod_pc) %>% mutate(mod = row.names(.)) %>% arrange(AIC)
aic_table
```

## Try temperature as random effect
### Bin temperature by sd's
```{r}
# Create categorical temperature bins based on standard deviations
dat3_nonas <- dat3_nonas %>% mutate(tcat = cut(T_initial, seq(-3, 3, 1), right = FALSE, labels = c(1:6)))
```

### Re-fit full models
```{r}
tcat_mass <- lmer(sline_speed_m_s ~ PC1*PC2*mass*treatment + (1|clutch/indiv) + (1|tcat), data = dat3_nonas, na.action = "na.fail", REML = FALSE) # FAILED TO CONVERGE

tcat_size <- lmer(sline_speed_m_s ~ PC1*PC2*size*treatment + (1|clutch/indiv) + (1|tcat), data = dat3_nonas, na.action = "na.fail", REML = FALSE)

tcat_gs <- lmer(sline_speed_m_s ~ PC1*PC2*gs*treatment +  (1|clutch/indiv) + (1|tcat), data = dat3_nonas, na.action = "na.fail", REML = FALSE) # SINGULAR

tcat_pc <- lmer(sline_speed_m_s ~ PC1*PC2*size_pc1*treatment + (1|clutch/indiv) + (1|tcat), data = dat3_nonas, na.action = "na.fail", REML = FALSE) # SINGULAR


#tcat_mass_best <- dredge(tcat_mass)[1,]
#tcat_size_best <- dredge(tcat_size)[1,]
#tcat_gs_best <- dredge(tcat_gs)[1,]
#tcat_pc_best <- dredge(tcat_pc)[1,]

#tcat_info_best <- list(tcat_mass_best, tcat_size_best, tcat_gs_best, tcat_pc_best)
#save(tcat_info_best, file = "data/outputs/tcat_info_best.Rda")

load("data/outputs/tcat_info_best.Rda")

# Make models from the info
tcat_info_best # look at the model selection table for the top models

# recreate the top models
mod_mass_tcat <- lmer(sline_speed_m_s ~ mass*treatment + PC2 + (1 | clutch/indiv) + (1 | tcat), data = dat3_nonas) # failed to converge

mod_size_tcat <- lmer(sline_speed_m_s ~ size*treatment + PC1 + (1 | clutch/indiv) + (1 | tcat), data = dat3_nonas) # is singular

mod_gs_tcat <- lmer(sline_speed_m_s ~ PC1*treatment*gs + (1 | clutch/indiv) + (1 | tcat), data = dat3_nonas) # is singular

mod_pc_tcat <- lmer(sline_speed_m_s ~ PC1*treatment*size_pc1 + (1 | clutch/indiv) + (1 | tcat), data = dat3_nonas) # is singular

aic_table_tcat <- AIC(mod_mass_tcat, mod_size_tcat, mod_gs_tcat, mod_pc_tcat) %>% mutate(mod = row.names(.)) %>% arrange(AIC)
aic_table_tcat
```
Models with temperature as a categorical random effect either don't converge or are singular. Seems like we should not do this.

## Check for multicollinearity
```{r}
vif(fullmodel_size)
vif(fullmodel_mass)
vif(fullmodel_gs)
vif(fullmodel_pc)
```

## Select model
```{r}
summary(mod_gs)
```

## Check for normality
```{r}
dat3_nonas <- dat3_nonas %>% mutate(resid = resid(mod_gs))
dat3_nonas %$% qqnorm(resid) # looks good! 

mod_gs

head(dat3_nonas)
dat3_nonas %>% ggplot(aes(x = PC1, y = resid))+
  geom_point() +
  facet_wrap(~treatment)

dat3_nonas %>% ggplot(aes(x = jitter(gs), y = resid))+
  geom_point() +
  facet_wrap(~treatment)

dat3_nonas %>% ggplot(aes(x = T_initial, y = resid))+
  geom_point() +
  facet_wrap(~treatment)

dat3_nonas %>% ggplot(aes(x = resid, col = treatment))+
  geom_density(aes(fill = treatment), alpha = 0.5)
```
Identity variance structure: each gs gets its own variance
Var_exp: variance is an exponent of the variable
For all of this we have to refit with nlme.
Hard to fit variance structure on mean-standardized data
Var_power should still work on negative number. Can also do combinations of e.g. var_power and var_ident

## Check for normality on the size_pc1 model instead 
```{r}
dat3_nonas <- dat3_nonas %>% mutate(resid_sizepc = resid(mod_pc))
dat3_nonas %$% qqnorm(resid_sizepc) # looks good! 

mod_pc

head(dat3_nonas)
dat3_nonas %>% ggplot(aes(x = PC1, y = resid_sizepc))+
  geom_point() +
  facet_wrap(~treatment)

dat3_nonas %>% ggplot(aes(x = jitter(size_pc1), y = resid_sizepc))+
  geom_point() +
  facet_wrap(~treatment)

dat3_nonas %>% ggplot(aes(x = T_initial, y = resid_sizepc))+
  geom_point() +
  facet_wrap(~treatment)

dat3_nonas %>% ggplot(aes(x = resid_sizepc, col = treatment))+
  geom_density(aes(fill = treatment), alpha = 0.5)
```


# ICCC 
## Calculate ICCC
```{r}
summary(mod_gs)
indiv_variance <- 1322e-04
clutch_variance <- 7.998e-12
resid_variance <- 1.182e-04

tot_rand_variance <- indiv_variance + clutch_variance + resid_variance
iccc_indiv <- indiv_variance/tot_rand_variance
iccc_clutch <- clutch_variance/tot_rand_variance

iccc_indiv # individual-level variance is a much larger component than clutch-level variance.
iccc_clutch
```

## Bootstrap CI's for ICCC
```{r}
calc_iccc_indiv <- function(model){
  mod_smy <- summary(model) # get the model summary
  df <- mod_smy$varcor %>% as.data.frame() # extract info about the random variables
  random_var <- sum(df$vcov) # total random variance
  iccc <- df$vcov[1]/random_var # variance of the chosen variable divided by total random variance
}

calc_iccc_clutch <- function(model){
  mod_smy <- summary(mod_gs) # get the model summary
  df <- mod_smy$varcor %>% as.data.frame() # extract info about the random variables
  random_var <- sum(df$vcov) # total random variance
  iccc <- df$vcov[2]/random_var # variance of the chosen variable divided by total random variance
}

calc_iccc_resid <- function(model){
  mod_smy <- summary(mod_gs) # get the model summary
  df <- mod_smy$varcor %>% as.data.frame() # extract info about the random variables
  random_var <- sum(df$vcov) # total random variance
  iccc <- df$vcov[3]/random_var # variance of the chosen variable divided by total random variance
}

# Bootstrapping for individual iccc
boot_iccc_indiv <- bootMer(mod_gs, calc_iccc_indiv, nsim = 1000, .progress = "txt")
boot_iccc_clutch <- bootMer(mod_gs, calc_iccc_clutch, nsim = 1000, .progress = "txt")
boot_iccc_resid <- bootMer(mod_gs, calc_iccc_resid, nsim = 1000, .progress = "txt")

iccc_indiv_vec <- boot_iccc_indiv$t
iccc_clutch_vec <- boot_iccc_clutch$t
iccc_resid_vec <- boot_iccc_resid$t

# Make a data frame for visualization
iccc <- data.frame(level = c(rep("clutch", 1000), rep("indiv", 1000), rep("resid", 1000)),
                   iccc_estimate = c(iccc_clutch_vec, iccc_indiv_vec, iccc_resid_vec))
```

## Visualize 
```{r}
iccc %>% ggplot(aes(x = level, y = iccc_estimate))+
  theme_minimal()+
  geom_boxplot()+
  ylab("ICCC")+
  xlab("Random variable")
```

# Plasticity
## Differences in means
### Individual means
```{r}
indiv_means <- dat3_nonas %>% group_by(indiv) %>% 
  summarize(indiv_mean_speed = mean(sline_speed_m_s),
            clutch = clutch[1],
            treatment = treatment[1],
            pond = pond[1]) 

head(indiv_means)
```

### Clutch means
```{r}
clutch_means <- indiv_means %>% 
  group_by(clutch, treatment) %>% 
  summarize(clutch_mean_speed = mean(indiv_mean_speed))

clutch_means %>% arrange(clutch)
clutch_means %$% table(clutch) #ADD THIS TO THE TUTORIAL!!!
```

#### Remove clutches not in both treatments
```{r}
clutch_means <- clutch_means %>% 
  group_by(clutch) %>%
  mutate(freq = n()) %>%
  ungroup() %>%
  filter(freq == 2) %>%
  select(-freq)

# We actually only removed CPS 1, which didn't occur in the Low treatment (probably because they all died?)
```

###Treatment differences
```{r}
treatment_diffs <- clutch_means %>%
  group_by(clutch) %>%
  summarize(diff = clutch_mean_speed[treatment == "Low"] - clutch_mean_speed[treatment == "High"])

treatment_diffs %>% ggplot(aes(x = diff))+
  geom_histogram()
```
What I've calculated here is D, the "scope of plastic response" (Stearns 1992, cited in Valladares _et al._ 2006): mean at low resource availability - mean at high resource availability. (note low vs. high is switched from the paper because in this case high temp ~ slower speed.)

## Individuals vs. means
### Opposite treatment means
```{r}
clutch_means <- clutch_means %>%
  group_by(clutch) %>%
  mutate(opposite_clutch_mean = case_when(treatment == "High" ~ clutch_mean_speed[treatment == "Low"],
                                   treatment == "Low" ~ clutch_mean_speed[treatment == "High"]))

head(clutch_means)
```

### Join to individual means
```{r}
indiv_means <- indiv_means %>%
  left_join(clutch_means, by = c("treatment", "clutch"))

head(indiv_means)
```

### Indiv/opp clutch differences
If we always subtract individual - mean, or always mean - individual, the distribution will be centered around 0 because we'll be subtracting a mixture of high-low and low-high. Need to be consistent with temperatures, which means inconsistent with direction of subtraction.

We're going to default to always subtracting low - high. 
```{r}
indiv_means <- indiv_means %>%
  mutate(indiv_opp_clutch_diff = case_when(treatment == "High" ~ opposite_clutch_mean - indiv_mean_speed,
                                           treatment == "Low" ~ indiv_mean_speed - opposite_clutch_mean))
```

### Simplify data
```{r}
plasticity <- indiv_means %>% select(-c(clutch_mean_speed)) %>% rename(D = indiv_opp_clutch_diff)
```

### Fit model predicting difference by pond
```{r}
head(plasticity)
pls_mod <- lmer(D ~ pond + (1|clutch), data = plasticity)
summary(pls_mod)

plot(pls_mod) # plot residuals: they look good.

# plot effect sizes


```



# Morphology vs. Burst Speed
Does morphology help to explain burst speed? And does this relationship hold in wild populations?

## Model for lab tadpoles
### Subset data
```{r}
head(dat3_nonas)

morpho_nonas <- dat3_nonas %>% select(tadpole, pond, clutch, indiv, treatment, trial, sline_speed_m_s, PC1, PC2, size, mass, gs, size_pc1)

# morpho_nonas %>% select(PC1, PC2, size, mass, gs, treatment, size_pc1) %>% ggpairs() # take a look at the variables

morpho_nonas_small <- morpho_nonas %>% select(PC1, PC2, size_pc1, treatment, indiv, clutch, pond, tadpole, sline_speed_m_s)
```

### Full model
Keeping the random effect structure from mod_gs
```{r}
summary(mod_gs)

full_morpho_mod <-lmer(sline_speed_m_s ~ PC1*PC2*size_pc1*treatment + (1|clutch/indiv), data = morpho_nonas_small, na.action = "na.fail", REML = FALSE) 
```

### Dredge
```{r}
dr <- dredge(full_morpho_mod)
```

### Fit best model
```{r}
dr[1:5,] # Look at the top of the dredge table

# Best model from that table, re-fit with REML = TRUE
morpho_mod <- lmer(sline_speed_m_s ~ PC1*treatment + size_pc1*treatment + (1|clutch/indiv), data = morpho_nonas_small, REML = TRUE, na.action = "na.fail")
summary(morpho_mod)
```

### Examine residuals
```{r}
morpho_resid <- resid(morpho_mod)
hist(morpho_resid)
qqnorm(morpho_resid)
```

## Wild tadpoles
### Clean wild data
```{r}
head(wild)
wild_nonas <- wild[complete.cases(wild),] # remove NA's

# Create PC variable for size
size_pca <- prcomp(wild_nonas %>% select(gs, size, mass))
wild_nonas$size_pc1 <- size_pca$x[,1]# put the size principal component into the data frame

wild_nonas <- wild_nonas %>% mutate_at(.vars = c("PC1", "PC2", "mass", "size", "gs", "size_pc1", "T_initial"), standardize)

wild_nonas <- wild_nonas %>% mutate(tcat = cut(T_initial, seq(-3, 3, 1), right = FALSE, labels = c(1:6)))

head(wild_nonas)
```

### Explore wild data
```{r}
# Any differences by pond?
wild_nonas %>% ggplot(aes(x = size_pc1, y = sline_speed_m_s, col = T_initial))+
  geom_smooth(method = "lm", col = "gray", se = F)+
  geom_point()+
  facet_wrap(~pond)+
  scale_color_viridis()

# Size_pc1
wild_nonas %>% 
  ggplot(aes(x = size_pc1, y = sline_speed_m_s, col = pond))+
  geom_smooth(method = "lm", se = F)+
  geom_point()+
  scale_color_viridis(discrete = TRUE)

# Size
wild_nonas %>% 
  ggplot(aes(x = size, y = sline_speed_m_s, col = pond))+
  geom_smooth(method = "lm", se = F)+
  geom_point()+
  scale_color_viridis(discrete = TRUE)

# Gosner stage
wild_nonas %>% 
  ggplot(aes(x = gs, y = sline_speed_m_s, col = pond))+
  geom_smooth(method = "lm", se = F)+
  geom_point()+
  scale_color_viridis(discrete = TRUE)

# Mass
wild_nonas %>% 
  ggplot(aes(x = mass, y = sline_speed_m_s, col = pond))+
  geom_smooth(method = "lm", se = F)+
  geom_point()+
  scale_color_viridis(discrete = TRUE)

# Shape PC1
wild_nonas %>% 
  ggplot(aes(x = PC1, y = sline_speed_m_s, col = pond))+
  geom_smooth(method = "lm", se = F)+
  geom_point()+
  scale_color_viridis(discrete = TRUE)

# Shape PC2
wild_nonas %>% 
  ggplot(aes(x = PC2, y = sline_speed_m_s, col = pond))+
  geom_smooth(method = "lm", se = F)+
  geom_point()+
  scale_color_viridis(discrete = TRUE)
```




### Testing wild models
```{r}
morpho_wild_1 <- lmer(sline_speed_m_s ~ size_pc1*T_initial + (1|pond), data = wild_nonas)
summary(morpho_wild_1)

wild_nonas %>% ggplot(aes(x = size_pc1, y = sline_speed_m_s, col = T_initial))+
  geom_point()+
  theme_minimal()+
  scale_color_viridis()

morpho_wild_2 <- lmer(sline_speed_m_s ~ size_pc1*tcat + (1|pond), data = wild_nonas)
```

