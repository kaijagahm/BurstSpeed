---
title: "Analysis"
author: "Kaija Gahm"
date: "1/22/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load libraries
```{r, echo = F}
source("libraries.R")
```

# Load data
## Select relevant columns and change data types
```{r}
load("data/outputs/stats_fast3.Rda")
dat3 <- stats_fast3 %>% select(tadpole, trial, indiv, treatment, sline_speed_m_s, PC1, PC2, pond, size, clutch, mass, gs, T_initial) %>% ungroup() %>% mutate(treatment = factor(treatment),
                                                      pond = factor(pond),
                                                      clutch = factor(clutch)) %>% 
  filter(treatment %in% c("High", "Low"), !is.na(PC1)) %>% droplevels()
```

## Remove observations that are NA for mass
```{r}
dat3 <- dat3 %>% filter(!is.na(mass))
```

# Code random effects explicitly
We should have used different letters for the individuals in the two temperature treatments, because strictly speaking we should have labeled the individuals before choosing which ones to put into which temperature treatment. We did select those randomly, but the naming scheme that we chose does not reflect that.

We don't want to change the letters on the tadpoles because that would make the data be out of sync with all of the labels on everything up to this point. Instead, we're going to stick with our scheme of appending "high" or "low" to the names to distinguish e.g. CPS_01_A in high/low treatments (since that is NOT the same individual.)
```{r}
dat3 <- dat3 %>% # remove tadpole column
  mutate(clutch = factor(paste(pond, clutch)), # code clutches explicitly
         indiv = factor(paste(clutch, indiv, treatment))) # code individuals explicitly
locate.nas(dat3)
```


# Mixed modeling
Hierarchical mixed model, incorporating pond within clutch and accounting for multiple trials per individual
Dat3: fastest 3 trials per tadpole

## Establish random effect structure
```{r}
library(lmerTest)
mod1 <- lmer(sline_speed_m_s ~ treatment * mass + (1|pond/clutch) + (1|indiv), data = dat3)
summary(mod1)

# removing the pond random effect, because it doesn't tell us anything. In fact, we need to do this to get a non-singular fit.
mod2 <- lmer(sline_speed_m_s ~ treatment * mass + (1|pond:clutch) + (1|indiv), data = dat3)
mod3 <- lmer(sline_speed_m_s ~ treatment * mass + (1|clutch/indiv), data = dat3) # use this syntax, but remember that clutch already accounts for being nested within pond. 

# : specifies that clutch is nested within pond, but without first fitting pond (since we discovered we don't need to)
# / explicitly fits pond first and then clutch.


dat3$predicted_speed <- predict(mod1, re.form = NA, newdata = dat3)
dat3$predicted_speed_withresids <- predict(mod1, re.form = NA, newdata = dat3) + resid(mod1, newdata = dat3)
```

## Check random effect structure
```{r}
# Compare ggplots
dat3 %>% ggplot(aes(x = mass, y = sline_speed_m_s, col = treatment))+
  geom_point()+
  geom_smooth(method = "lm")+
  ylab("speed")+
  ggtitle("Original data")

dat3 %>% ggplot(aes(x = mass, y = predicted_speed, col = treatment))+
  geom_point()+
  geom_smooth(method = "lm")+
  ylab("predicted_speed")+
  ggtitle("Predicted data")

dat3 %>% ggplot(aes(x = mass, y = predicted_speed_withresids, col = treatment))+
  geom_point()+
  geom_smooth(method = "lm")+
  ylab("predicted_speed_withresids")+
  ggtitle("Predicted data with residuals")
```
The similarity between these graphs shows us that we have correctly specified the structure of our random effects

## Figure out main effects
### Investigate correlations
```{r}
dat3 %>% select(PC1, PC2, size, mass, gs, T_initial, treatment) %>% ggpairs()
```
Size, mass, and gosner stage are all closely correlated. 

### Remove NA's
```{r}
dat3_nonas <- dat3 %>% filter(!is.na(T_initial))
```

### PCA on size variables
```{r}
size_pca <- prcomp(dat3_nonas %>% select(gs, size, mass))
dat3_nonas$size_pc1 <- size_pca$x[,1]# put the size principal component into the data frame
```

### Standardize variables
```{r}
# Function to calculate z scores
standardize <- function(vector){
  mu <- mean(vector)
  sd <- sd(vector)
  z_vector <- (vector-mu)/sd
  return(z_vector)
}

dat3_nonas <- dat3_nonas %>% mutate_at(.vars = c("PC1", "PC2", "mass", "size", "gs", "size_pc1", "T_initial"), standardize)
```

### Fit full models
```{r}
fullmodel_mass <- lmer(sline_speed_m_s ~ PC1*PC2*mass*treatment + T_initial + (1|clutch/indiv), data = dat3_nonas, na.action = "na.fail", REML = FALSE) 

fullmodel_size <- lmer(sline_speed_m_s ~ PC1*PC2*size*treatment + T_initial + (1|clutch/indiv), data = dat3_nonas, na.action = "na.fail", REML = FALSE)

fullmodel_gs <- lmer(sline_speed_m_s ~ PC1*PC2*gs*treatment + T_initial + (1|clutch/indiv), data = dat3_nonas, na.action = "na.fail", REML = FALSE) # SINGULAR

fullmodel_pc <- lmer(sline_speed_m_s ~ PC1*PC2*size_pc1*treatment + T_initial + (1|clutch/indiv), data = dat3_nonas, na.action = "na.fail", REML = FALSE) # SINGULAR
```

### Dredge full models
```{r}
#dredge_mass_best <- dredge(fullmodel_mass)[1,]
#dredge_size_best <- dredge(fullmodel_size)[1,]
#dredge_gs_best <- dredge(fullmodel_gs)[1,]
#dredge_pc_best <- dredge(fullmodel_pc)[1,]

#dredge_info_best <- list(dredge_mass_best, dredge_size_best, dredge_gs_best, dredge_pc_best)
#save(dredge_info_best, file = "data/outputs/dredge_info_best.Rda")

load("data/outputs/dredge_info_best.Rda")

# Make models from the info
dredge_info_best # look at the model selection table for the top models

# recreate the top models
mod_mass <- lmer(sline_speed_m_s ~ mass*treatment + PC2 + T_initial + (1 | clutch/indiv), data = dat3_nonas)

mod_size <- lmer(sline_speed_m_s ~ size*treatment + PC1 + T_initial + (1 | clutch/indiv), data = dat3_nonas)

mod_gs <- lmer(sline_speed_m_s ~ gs*treatment*PC1 + T_initial + (1 | clutch/indiv), data = dat3_nonas)

mod_pc <- lmer(sline_speed_m_s ~ PC1*treatment*size_pc1 + T_initial + (1 | clutch/indiv), data = dat3_nonas) # this one is singular

aic_table <- AIC(mod_mass, mod_size, mod_gs, mod_pc) %>% mutate(mod = row.names(.)) %>% arrange(AIC)
aic_table
```

## Try temperature as random effect
### Bin temperature by sd's
```{r}
# Create categorical temperature bins based on standard deviations
dat3_nonas <- dat3_nonas %>% mutate(tcat = cut(T_initial, seq(-3, 3, 1), right = FALSE, labels = c(1:6)))
```

### Re-fit full models
```{r}
tcat_mass <- lmer(sline_speed_m_s ~ PC1*PC2*mass*treatment + (1|clutch/indiv) + (1|tcat), data = dat3_nonas, na.action = "na.fail", REML = FALSE) # FAILED TO CONVERGE

tcat_size <- lmer(sline_speed_m_s ~ PC1*PC2*size*treatment + (1|clutch/indiv) + (1|tcat), data = dat3_nonas, na.action = "na.fail", REML = FALSE)

tcat_gs <- lmer(sline_speed_m_s ~ PC1*PC2*gs*treatment +  (1|clutch/indiv) + (1|tcat), data = dat3_nonas, na.action = "na.fail", REML = FALSE) # SINGULAR

tcat_pc <- lmer(sline_speed_m_s ~ PC1*PC2*size_pc1*treatment + (1|clutch/indiv) + (1|tcat), data = dat3_nonas, na.action = "na.fail", REML = FALSE) # SINGULAR


#tcat_mass_best <- dredge(tcat_mass)[1,]
#tcat_size_best <- dredge(tcat_size)[1,]
#tcat_gs_best <- dredge(tcat_gs)[1,]
#tcat_pc_best <- dredge(tcat_pc)[1,]

#tcat_info_best <- list(tcat_mass_best, tcat_size_best, tcat_gs_best, tcat_pc_best)
#save(tcat_info_best, file = "data/outputs/tcat_info_best.Rda")

load("data/outputs/tcat_info_best.Rda")

# Make models from the info
tcat_info_best # look at the model selection table for the top models

# recreate the top models
mod_mass_tcat <- lmer(sline_speed_m_s ~ mass*treatment + PC2 + (1 | clutch/indiv) + (1 | tcat), data = dat3_nonas) # failed to converge

mod_size_tcat <- lmer(sline_speed_m_s ~ size*treatment + PC1 + (1 | clutch/indiv) + (1 | tcat), data = dat3_nonas) # is singular

mod_gs_tcat <- lmer(sline_speed_m_s ~ PC1*treatment*gs + (1 | clutch/indiv) + (1 | tcat), data = dat3_nonas) # is singular

mod_pc_tcat <- lmer(sline_speed_m_s ~ PC1*treatment*size_pc1 + (1 | clutch/indiv) + (1 | tcat), data = dat3_nonas) # is singular

aic_table_tcat <- AIC(mod_mass_tcat, mod_size_tcat, mod_gs_tcat, mod_pc_tcat) %>% mutate(mod = row.names(.)) %>% arrange(AIC)
aic_table_tcat
```
Models with temperature as a categorical random effect either don't converge or are singular. Seems like we should not do this.

## Check for multicollinearity
```{r}
vif(fullmodel_size)
vif(fullmodel_mass)
vif(fullmodel_gs)
vif(fullmodel_pc)
```

## Select model
```{r}
summary(mod_gs)
```

## Check for normality
```{r}
residuals <- resid(mod_gs)
residuals %>% qqnorm() # looks good! 
```

# ICCC 
## Calculate ICCC
```{r}
summary(mod_gs)
indiv_variance <- 1322e-04
clutch_variance <- 7.998e-12
resid_variance <- 1.182e-04

tot_rand_variance <- indiv_variance + clutch_variance + resid_variance
iccc_indiv <- indiv_variance/tot_rand_variance
iccc_clutch <- clutch_variance/tot_rand_variance

iccc_indiv # individual-level variance is a much larger component than clutch-level variance.
iccc_clutch
```

## Bootstrap CI's for ICCC
```{r}
calc_iccc_indiv <- function(model){
  mod_smy <- summary(model) # get the model summary
  df <- mod_smy$varcor %>% as.data.frame() # extract info about the random variables
  random_var <- sum(df$vcov) # total random variance
  iccc <- df$vcov[1]/random_var # variance of the chosen variable divided by total random variance
}

calc_iccc_clutch <- function(model){
  mod_smy <- summary(mod_gs) # get the model summary
  df <- mod_smy$varcor %>% as.data.frame() # extract info about the random variables
  random_var <- sum(df$vcov) # total random variance
  iccc <- df$vcov[2]/random_var # variance of the chosen variable divided by total random variance
}

calc_iccc_resid <- function(model){
  mod_smy <- summary(mod_gs) # get the model summary
  df <- mod_smy$varcor %>% as.data.frame() # extract info about the random variables
  random_var <- sum(df$vcov) # total random variance
  iccc <- df$vcov[3]/random_var # variance of the chosen variable divided by total random variance
}

# Bootstrapping for individual iccc
boot_iccc_indiv <- bootMer(mod_gs, calc_iccc_indiv, nsim = 1000, .progress = "txt")
boot_iccc_clutch <- bootMer(mod_gs, calc_iccc_clutch, nsim = 1000, .progress = "txt")
boot_iccc_resid <- bootMer(mod_gs, calc_iccc_resid, nsim = 1000, .progress = "txt")

iccc_indiv_vec <- boot_iccc_indiv$t
iccc_clutch_vec <- boot_iccc_clutch$t
iccc_resid_vec <- boot_iccc_resid$t

# Make a data frame for visualization
iccc <- data.frame(level = c(rep("clutch", 1000), rep("indiv", 1000), rep("resid", 1000)),
                   iccc_estimate = c(iccc_clutch_vec, iccc_indiv_vec, iccc_resid_vec))
```

## Visualize 
```{r}
iccc %>% ggplot(aes(x = level, y = iccc_estimate))+
  theme_minimal()+
  geom_boxplot()+
  ylab("ICCC")+
  xlab("Random variable")
```

# Plasticity
## Individual means
```{r}
indiv_means <- dat3_nonas %>% group_by(indiv) %>% 
  summarize(mean_speed = mean(sline_speed_m_s),
            clutch = clutch[1],
            treatment = treatment[1]) 

head(indiv_means)
```

## Clutch means
```{r}
clutch_means <- indiv_means %>% 
  group_by(clutch, treatment) %>% 
  summarize(clutch_mean_speed = mean(mean_speed))

clutch_means %>% arrange(clutch)
clutch_means %$% table(clutch) #ADD THIS TO THE TUTORIAL!!!
```

### Remove clutches not in both treatments
```{r}
clutch_means <- clutch_means %>% 
  group_by(clutch) %>%
  mutate(freq = n()) %>%
  ungroup() %>%
  filter(freq == 2) %>%
  select(-freq)

# We actually only removed CPS 1, which didn't occur in the Low treatment (probably because they all died?)
```

## Treatment differences
```{r}
treatment_diffs <- clutch_means %>%
  group_by(clutch) %>%
  summarize(diff = clutch_mean_speed[treatment == "Low"] - clutch_mean_speed[treatment == "High"])

treatment_diffs %>% ggplot(aes(x = diff))+
  geom_histogram()
```

