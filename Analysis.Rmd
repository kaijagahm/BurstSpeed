---
title: "Analysis"
author: "Kaija Gahm"
date: "1/22/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load libraries
```{r, echo = F}
source("libraries.R")
```

# Load data
```{r}
load("data/outputs/stats_fast3.Rda")
```

# Code random effects explicitly
We should have used different letters for the individuals in the two temperature treatments, because strictly speaking we should have labeled the individuals before choosing which ones to put into which temperature treatment. We did select those randomly, but the naming scheme that we chose does not reflect that.

We don't want to change the letters on the tadpoles because that would make the data be out of sync with all of the labels on everything up to this point. Instead, we're going to stick with our scheme of appending "high" or "low" to the names to distinguish e.g. CPS_01_A in high/low treatments (since that is NOT the same individual.)
```{r}
stats_fast3 <- stats_fast3 %>% # remove tadpole column
  mutate(clutch = factor(paste(pond, clutch)), # code clutches explicitly
         indiv = factor(paste(clutch, indiv, treatment))) # code individuals explicitly
locate.nas(stats_fast3)
```

## Select relevant columns and change data types
```{r}
dat3 <- stats_fast3 %>% select(tadpole, trial, indiv, treatment, sline_speed_m_s, PC1, PC2, pond, size, clutch, mass, gs, T_initial) %>% ungroup() %>% mutate(treatment = factor(treatment),
                     pond = factor(pond),
                     clutch = factor(clutch)) %>%
  filter(treatment %in% c("High", "Low"), !is.na(PC1)) %>% droplevels()

wild <- stats_fast3 %>% select(tadpole, trial, treatment, sline_speed_m_s, PC1, PC2, pond, size, mass, gs, T_initial) %>% ungroup() %>% mutate(treatment = factor(treatment),
                     pond = factor(pond)) %>% 
  filter(treatment == "Wild") %>% droplevels()
```







# ICCC 
## Calculate ICCC
```{r}
summary(mod_gs)
indiv_variance <- 1322e-04
clutch_variance <- 7.998e-12
resid_variance <- 1.182e-04

tot_rand_variance <- indiv_variance + clutch_variance + resid_variance
iccc_indiv <- indiv_variance/tot_rand_variance
iccc_clutch <- clutch_variance/tot_rand_variance

iccc_indiv # individual-level variance is a much larger component than clutch-level variance.
iccc_clutch
```

## Bootstrap CI's for ICCC
```{r}
calc_iccc_indiv <- function(model){
  mod_smy <- summary(model) # get the model summary
  df <- mod_smy$varcor %>% as.data.frame() # extract info about the random variables
  random_var <- sum(df$vcov) # total random variance
  iccc <- df$vcov[1]/random_var # variance of the chosen variable divided by total random variance
}

calc_iccc_clutch <- function(model){
  mod_smy <- summary(mod_gs) # get the model summary
  df <- mod_smy$varcor %>% as.data.frame() # extract info about the random variables
  random_var <- sum(df$vcov) # total random variance
  iccc <- df$vcov[2]/random_var # variance of the chosen variable divided by total random variance
}

calc_iccc_resid <- function(model){
  mod_smy <- summary(mod_gs) # get the model summary
  df <- mod_smy$varcor %>% as.data.frame() # extract info about the random variables
  random_var <- sum(df$vcov) # total random variance
  iccc <- df$vcov[3]/random_var # variance of the chosen variable divided by total random variance
}

# Bootstrapping for individual iccc
boot_iccc_indiv <- bootMer(mod_gs, calc_iccc_indiv, nsim = 1000, .progress = "txt")
boot_iccc_clutch <- bootMer(mod_gs, calc_iccc_clutch, nsim = 1000, .progress = "txt")
boot_iccc_resid <- bootMer(mod_gs, calc_iccc_resid, nsim = 1000, .progress = "txt")

iccc_indiv_vec <- boot_iccc_indiv$t
iccc_clutch_vec <- boot_iccc_clutch$t
iccc_resid_vec <- boot_iccc_resid$t

# Make a data frame for visualization
iccc <- data.frame(level = c(rep("clutch", 1000), rep("indiv", 1000), rep("resid", 1000)),
                   iccc_estimate = c(iccc_clutch_vec, iccc_indiv_vec, iccc_resid_vec))
```

## Visualize 
```{r}
iccc %>% ggplot(aes(x = level, y = iccc_estimate))+
  theme_minimal()+
  geom_boxplot()+
  ylab("ICCC")+
  xlab("Random variable")
```

# Plasticity
## Differences in means
### Individual means
```{r}
indiv_means <- dat3_nonas %>% group_by(indiv) %>% 
  summarize(indiv_mean_speed = mean(sline_speed_m_s),
            clutch = clutch[1],
            treatment = treatment[1],
            pond = pond[1]) 

head(indiv_means)
```

### Clutch means
```{r}
clutch_means <- indiv_means %>% 
  group_by(clutch, treatment) %>% 
  summarize(clutch_mean_speed = mean(indiv_mean_speed))

clutch_means %>% arrange(clutch)
clutch_means %$% table(clutch) #ADD THIS TO THE TUTORIAL!!!
```

#### Remove clutches not in both treatments
```{r}
clutch_means <- clutch_means %>% 
  group_by(clutch) %>%
  mutate(freq = n()) %>%
  ungroup() %>%
  filter(freq == 2) %>%
  select(-freq)

# We actually only removed CPS 1, which didn't occur in the Low treatment (probably because they all died?)
```

###Treatment differences
```{r}
treatment_diffs <- clutch_means %>%
  group_by(clutch) %>%
  summarize(diff = clutch_mean_speed[treatment == "Low"] - clutch_mean_speed[treatment == "High"])

treatment_diffs %>% ggplot(aes(x = diff))+
  geom_histogram()
```
What I've calculated here is D, the "scope of plastic response" (Stearns 1992, cited in Valladares _et al._ 2006): mean at low resource availability - mean at high resource availability. (note low vs. high is switched from the paper because in this case high temp ~ slower speed.)

## Individuals vs. means
### Opposite treatment means
```{r}
clutch_means <- clutch_means %>%
  group_by(clutch) %>%
  mutate(opposite_clutch_mean = case_when(treatment == "High" ~ clutch_mean_speed[treatment == "Low"],
                                   treatment == "Low" ~ clutch_mean_speed[treatment == "High"]))

head(clutch_means)
```

### Join to individual means
```{r}
indiv_means <- indiv_means %>%
  left_join(clutch_means, by = c("treatment", "clutch"))

head(indiv_means)
```

### Indiv/opp clutch differences
If we always subtract individual - mean, or always mean - individual, the distribution will be centered around 0 because we'll be subtracting a mixture of high-low and low-high. Need to be consistent with temperatures, which means inconsistent with direction of subtraction.

We're going to default to always subtracting low - high. 
```{r}
indiv_means <- indiv_means %>%
  mutate(indiv_opp_clutch_diff = case_when(treatment == "High" ~ opposite_clutch_mean - indiv_mean_speed,
                                           treatment == "Low" ~ indiv_mean_speed - opposite_clutch_mean))
```

### Simplify data
```{r}
plasticity <- indiv_means %>% select(-c(clutch_mean_speed)) %>% rename(D = indiv_opp_clutch_diff)
```

### Fit model predicting difference by pond
```{r}
head(plasticity)
plasticity <- plasticity %>% mutate(clutch_only = factor(str_extract(clutch, pattern = "(?<= )[[:digit:]](?=$)")))

pls_mod <- lmer(D ~ pond + (1|clutch), data = plasticity)
summary(pls_mod)

plot(pls_mod) # plot residuals: they look good.

# Plot effect sizes
sjPlot::plot_model(pls_mod, type = "eff")

# Plot all D points
plasticity %>% ggplot(aes(x = pond, y = D))+
  geom_violin()+
  geom_jitter(aes(col = clutch_only), width = 0.1)+
  scale_color_viridis(discrete = T)
```



# Morphology vs. Burst Speed
Does morphology help to explain burst speed? And does this relationship hold in wild populations?

## Model for lab tadpoles
### Subset data
```{r}
head(dat3_nonas)

morpho_nonas <- dat3_nonas %>% select(tadpole, pond, clutch, indiv, treatment, trial, sline_speed_m_s, PC1, PC2, size, mass, gs, size_pc1)

# morpho_nonas %>% select(PC1, PC2, size, mass, gs, treatment, size_pc1) %>% ggpairs() # take a look at the variables

morpho_nonas_small <- morpho_nonas %>% select(PC1, PC2, size_pc1, treatment, indiv, clutch, pond, tadpole, sline_speed_m_s)
```

### Full model
Keeping the random effect structure from mod_gs
```{r}
summary(mod_gs)

full_morpho_mod <-lmer(sline_speed_m_s ~ PC1*PC2*size_pc1*treatment + (1|clutch/indiv), data = morpho_nonas_small, na.action = "na.fail", REML = FALSE) 
```

### Dredge
```{r}
dr <- dredge(full_morpho_mod)
```

### Fit best model
```{r}
dr[1:5,] # Look at the top of the dredge table

# Best model from that table, re-fit with REML = TRUE
morpho_mod <- lmer(sline_speed_m_s ~ PC1*treatment + size_pc1*treatment + (1|clutch/indiv), data = morpho_nonas_small, REML = TRUE, na.action = "na.fail")
summary(morpho_mod)
```

### Examine residuals
```{r}
morpho_resid <- resid(morpho_mod)
hist(morpho_resid)
qqnorm(morpho_resid)
```

## Wild tadpoles
### Clean wild data
```{r}
head(wild)
wild_nonas <- wild[complete.cases(wild),] # remove NA's

# Create PC variable for size
size_pca <- prcomp(wild_nonas %>% select(gs, size, mass))
wild_nonas$size_pc1 <- size_pca$x[,1]# put the size principal component into the data frame

wild_nonas <- wild_nonas %>% mutate_at(.vars = c("PC1", "PC2", "mass", "size", "gs", "size_pc1", "T_initial"), standardize)

wild_nonas <- wild_nonas %>% mutate(tcat = cut(T_initial, seq(-3, 3, 1), right = FALSE, labels = c(1:6)))

head(wild_nonas)
```

### Explore wild data
```{r}
# Any differences by pond?
wild_nonas %>% ggplot(aes(x = size_pc1, y = sline_speed_m_s, col = T_initial))+
  geom_smooth(method = "lm", col = "gray", se = F)+
  geom_point()+
  facet_wrap(~pond)+
  scale_color_viridis()

# Size_pc1
wild_nonas %>% 
  ggplot(aes(x = size_pc1, y = sline_speed_m_s, col = pond))+
  geom_smooth(method = "lm", se = F)+
  geom_point()+
  scale_color_viridis(discrete = TRUE)

# Size
wild_nonas %>% 
  ggplot(aes(x = size, y = sline_speed_m_s, col = pond))+
  geom_smooth(method = "lm", se = F)+
  geom_point()+
  scale_color_viridis(discrete = TRUE)

# Gosner stage
wild_nonas %>% 
  ggplot(aes(x = gs, y = sline_speed_m_s, col = pond))+
  geom_smooth(method = "lm", se = F)+
  geom_point()+
  scale_color_viridis(discrete = TRUE)

# Mass
wild_nonas %>% 
  ggplot(aes(x = mass, y = sline_speed_m_s, col = pond))+
  geom_smooth(method = "lm", se = F)+
  geom_point()+
  scale_color_viridis(discrete = TRUE)

# Shape PC1
wild_nonas %>% 
  ggplot(aes(x = PC1, y = sline_speed_m_s, col = pond))+
  geom_smooth(method = "lm", se = F)+
  geom_point()+
  scale_color_viridis(discrete = TRUE)

# Shape PC2
wild_nonas %>% 
  ggplot(aes(x = PC2, y = sline_speed_m_s, col = pond))+
  geom_smooth(method = "lm", se = F)+
  geom_point()+
  scale_color_viridis(discrete = TRUE)
```




### Testing wild models
```{r}
morpho_wild_1 <- lmer(sline_speed_m_s ~ size_pc1*T_initial + (1|pond), data = wild_nonas)
summary(morpho_wild_1)

wild_nonas %>% ggplot(aes(x = size_pc1, y = sline_speed_m_s, col = T_initial))+
  geom_point()+
  theme_minimal()+
  scale_color_viridis()

morpho_wild_2 <- lmer(sline_speed_m_s ~ size_pc1*tcat + (1|pond), data = wild_nonas)
```

